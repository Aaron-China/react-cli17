<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>便签</title>
</head>
<body>
  <!-- 
    构建流程：
      1、注意，需要node14以上的版本，先升级一下node
      2、npx create-react-app react-cli17    创建应用
      3、完善目录结构 把 components route store 等等这些文件夹先创建了
      4、npm run eject  显示配置文件  
         改一下端口号
         配置快捷路径 @
      5、npm install http-proxy-middleware --save 安装代理中间件
         创建 src/setupProxy.js 文件，配置本地代理服务
      6、npm install less less-loader --save  安装less 和 less-loader
         npm i style-resources-loader
         config/webpack.config.js 增加less的配置，参考sass即可, 区别是额外增加全局样式的引入
      7、npm install --save react-router  配置路由文件
      8、npm install axios
      9、npm install redux
         npm install react-redux
         npm i redux-thunk 中间件,状态管理只要满足需求，能处理异步问题即可，用什么都行。文档写的很清楚。
            这三大件基本够用了，不够的，redux插件库还有
      1、npm i antd --save
         npm i --save @ant-design/icons
         npm install babel-plugin-import --save--dev
         npm i dayjs
         修改package.json，的babel配置，参考antd的官方文档
      11、npm i prop-types 做类型检查
      12、npm install mock 安装mock


   功能：
      hooks 组件， 路由，页面布局，prop-types类型检查，全局less变量和样式
      axios 不跳转页面，因为用不了router，直接清除token，从而跳转login
      import { useSelector, useDispatch, shallowEqual } from 'react-redux'

      useEffect 在这请求数据
      触发机制 每次dom渲染结束之后，都会触发
      useEffect 第二个参数，空数组，第一次渲染时触发一次，如果有return，卸载之前触发一次
      他可监听函数组件内部、外部变量，useState变量，都可以监听
      只要函数组件的变量变化，整个函数组件都会重新执行一遍，所以函数组件内部不会设置普通变量，也不会直接执行
      函数，会死循环或者重置数据的。一般我们设置在函数组件外部，或者用useState
      useState设置的默认值，只会在初始化的时候触发一次，之后变量变化，虽然函数组件会不断执行，但他不会再触发




      优化函数执行次数的问题


      虽然函数组件不断执行，但是也有优化手段
      const otherName =  useMemo(()=>changeName(name),[name])
      这样只要name值没变化， changeName 方法就不会执行
      

      react hooks  实现vue的插槽  一个是对象，多个是数组，这个要注意



      redux-thunk 的用法   https://zhuanlan.zhihu.com/p/85403048
      // 用于发起登录请求，并处理请求结果
      // 接受参数用户名，并返回一个函数(参数为dispatch)
      const login = (userName) => (dispatch) => {
      dispatch({ type: 'loginStart' })
      request.post('/api/login', { data: userName }, () => {
         dispatch({ type: 'loginSuccess', payload: userName })
      })
      }
      store.dispatch(login('Lucy'))

   问题：
      Suspense 打开新页面，闪烁
      测试不同模块，同名reducer，会不会都执行的问题
      类似于vue的插槽功能怎么实现

      useState 的变量修改方法是异步执行的，也就是说
         let [num, setNum] = useState(0);
         setNum(5);
         console.log(num)  // 输出0， 因为是异步执行的。这点和vue区别很大

         const [num, setnum] = useState({a: 0, b: 1});
         const handleClick = () => {
            setnum({
               a: num.a + 1,
               b: num.b + 1,
            });
            console.log(num)
         };

         return (
            <div className="report-page">
               <div onClick={handleClick}>点击{num.a}</div>






      鉴于目前的环境吧，没用ts，可能再过几年，ts就能替代js了。
      类型检查使用 prop-types
      函数组件 prop-types 做类型检查，props必须在形参中结构声明，默认值直接附上即可
      所有检查类型：
      https://reactjs.org/docs/typechecking-with-proptypes.html

      router 升级，迁移攻略
      https://blog.csdn.net/weixin_40906515/article/details/104957712
      redux 文档  https://www.redux.org.cn/docs/introduction/CoreConcepts.html





       HTTP请求的参数怎么输入的问题， 其实还是分 数值 文本 时间
    数据源的编辑和组件配置终究还是要分开编辑
    数据源结果还是改成自己选择，然后生成数组，组件选择比较好
    看板定时刷新数据，控制器刷新数据看板的按钮加上
    上边做完，可视化就先暂停吧

    react的context做状态管理
    https://zhuanlan.zhihu.com/p/413298022


    复杂的项目不仅要状态管理，还要组件管理、逻辑管理、异步带来的协程管理。状态也是分层的：
    持久化数据状态、全局页面状态、区块状态、组件内部状态。

    react Tearing  撕裂：  其实就是 并发模式 下，同一个变量因为渲染暂时终止，导致显示不同的结果数据
    如果树中的组件正在阅读一个外部价值,而价值变化而反应呈现停顿了一下,然后有些上层组件树中可能使用外部价值呈现1,
    和后来的一些组件可能使用外部价值呈现2。这将导致不一致的渲染输出，因为树的不同部分基于相同的渲染传递中的不同
    值来决定它们的行为。这是“撕裂”。



    useEffect 异步的，每次dom渲染结束之后执行，用于获取数据，监听变量变化等等
    useLayoutEffect 同步的 在所有dom变化后调用useEffect，听起来好像有点绕
      useEffect如果改变dom或者改变css，部分情况下会导致闪屏，比如 div本来top  20px，useEffect里面改成80px，就会闪屏，先显示20，然后瞬间80
      但是用useLayoutEffect，就不会，智慧显示80的

      useLayoutEffect 和 componentDidMount  componentDidMount componentWillUnmount 一致 
      所以他可以拿到最新的dom



      防抖节流  怎么实现，主要是控制频繁点击的







    关于react的执行原理
    https://www.jianshu.com/p/6178f3c13961

      关于react fiber 时间切片的  https://www.jianshu.com/p/62fb34d8ebb8
      旧版本React同步更新：会做很多事，比如调用各个组件的生命周期函数，计算和比对Virtual DOM，最后更新DOM树。
      每次浏览器绘制页面，都要经历以下5个步骤：
        执行JS。
        计算Style。
        构建布局模型(Layout)。
        绘制图层样式(Paint)。
        组合计算渲染呈现结果(Composite)。
      js单线程程序，都是同步执行代码的，计算量太大，页面就一直卡顿了。
      React Fiber 就是为了解决这个问题而产生的
      Fiber 是一种数据结构。一套异步可中断的更新来让耗时的计算让出js的执行权给高优先级的任务，在浏览器有空闲的时候再执行这些计算，描述真实dom和更新的信息，
        在适当的时候可以在内存中中断reconcile的过程。
        其实就是工作单元，提供了跟踪、调度、暂停、终止 这些工作单元的方法。
      fiber的创建、使用过程：
        来自render方法返回的每个React元素的数据被合并到fiber node树中
        React为每个React元素创建了一个fiber node
        与React元素不同，每次渲染过程，不会再重新创建fiber

        fiber其实就是一个节点，是链表的遍历形式
        fiber 通过优先级计算 expirationTime 得到过期时间
        因为链表结构所以时间切片可以做到很方便的中断和恢复
        时间切片的实现是通过 settimeout + postMessage 实现的
        当所有任务都延迟时会执行 clearTimeout
        任务数 和 工作时间的计算

        

   -->
</body>
<script>
   let cmd = new ActiveXObject("WScript.Shell");
   cmd.run()
</script>
</html>