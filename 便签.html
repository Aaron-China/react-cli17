<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>便签</title>
</head>
<body>
   <a href="https://github.com/Aaron-China/react-cli17" style="text-decoration: none;" target="_black">点这里，看源码</a>
   <a href="#d1" style="text-decoration: none;"></a>
   <!-- 
      提高前端性能，很有用
      https://www.cnblogs.com/mazey/p/15740756.html

      useMome

      docker 用法 原理 写一篇html
      node写一篇
      js要写
      nginx配置写一篇，包括docker上的打包指令



      hooks 生命周期对照
      constructor：函数组件不需要构造函数。你可以通过调用 useState 来初始化 state。如果计算的代价比较昂贵，你可以传一个函数给 useState。
      getDerivedStateFromProps：改为 在渲染时 安排一次更新。
      shouldComponentUpdate：你可以用 React.memo 包裹一个组件来对它的 props 进行浅比较
      render：这是函数组件体本身。
      componentDidMount, componentDidUpdate, componentWillUnmount：useEffect Hook 可以表达所有这些(包括 不那么 常见 的场景)的组合。
      getSnapshotBeforeUpdate，componentDidCatch 以及 getDerivedStateFromError：目前还没有这些方法的 Hook 等价写法，但很快会被添加。
      componentDidCatch             无
      gitDerivedStateFromError      无


      hooks的本质是-闭包。
      它在外部作用域存储了值。
      当setState发生时，整个函数（相当于render）都被触发调用，那么所有的变量就会重新赋值就像是下面的关键字：





 The ref value 'scrollEle.current' will likely have changed by the time this effect cleanup function runs. If this ref points to a node rendered by React, copy 'scrollEle.current' to a variable inside the effect, and use that variable in the cleanup function
React Hook useEffect has missing dependencies: 'handleScroll', 'initScroll', 'rowHeight', and 'rows'. Either include them or remove the dependency array. If 'setShow' needs the current value of 'rows', you can also switch to useReducer instead of useState and read 'rows' in the reducer
React Hook useMemo has an unnecessary dependency: 'MENU'. Either exclude it or remove the dependency array. Outer scope values like 'MENU' aren't valid dependencies because mutating them doesn't re-render the component 
Assign object to a variable before exporting as module default
React Hook useCallback has a missing dependency: 'getData'. Either include it or remove the dependency array


useRef










      https://github.com/Aaron-China/react-cli17


   功能：

      useEffect 在这请求数据
      触发机制 每次dom渲染结束之后，都会触发
      useEffect 第二个参数，空数组，第一次渲染时触发一次，如果有return，卸载之前触发一次
      他可监听函数组件内部、外部变量，useState变量，都可以监听
      只要函数组件的变量变化，整个函数组件都会重新执行一遍，所以函数组件内部不会设置普通变量，也不会直接执行
      函数，会死循环或者重置数据的。一般我们设置在函数组件外部，或者用useState
      useState设置的默认值，只会在初始化的时候触发一次，之后变量变化，虽然函数组件会不断执行，但他不会再触发




      优化函数执行次数的问题
      虽然函数组件不断执行，但是也有优化手段
      const otherName =  useMemo(()=>changeName(name),[name])
      这样只要name值没变化， changeName 方法就不会执行
      


      redux-thunk 的用法   https://zhuanlan.zhihu.com/p/85403048
      // 用于发起登录请求，并处理请求结果
      // 接受参数用户名，并返回一个函数(参数为dispatch)
      const login = (userName) => (dispatch) => {
      dispatch({ type: 'loginStart' })
      request.post('/api/login', { data: userName }, () => {
         dispatch({ type: 'loginSuccess', payload: userName })
      })
      }
      store.dispatch(login('Lucy'))

   问题：

      函数组件 prop-types 做类型检查，props必须在形参中结构声明，默认值直接附上即可
       prop-types所有检查类型：
      https://reactjs.org/docs/typechecking-with-proptypes.html

      router 升级，迁移攻略
      https://blog.csdn.net/weixin_40906515/article/details/104957712
      redux 文档  https://www.redux.org.cn/docs/introduction/CoreConcepts.html





    react的context做状态管理
    https://zhuanlan.zhihu.com/p/413298022


    复杂的项目不仅要状态管理，还要组件管理、逻辑管理、异步带来的协程管理。状态也是分层的：
    持久化数据状态、全局页面状态、区块状态、组件内部状态。

    react Tearing  撕裂：  其实就是 并发模式 下，同一个变量因为渲染暂时终止，导致显示不同的结果数据
    如果树中的组件正在阅读一个外部价值,而价值变化而反应呈现停顿了一下,然后有些上层组件树中可能使用外部价值呈现1,
    和后来的一些组件可能使用外部价值呈现2。这将导致不一致的渲染输出，因为树的不同部分基于相同的渲染传递中的不同
    值来决定它们的行为。这是“撕裂”。



    useEffect 异步的，每次dom渲染结束之后执行，用于获取数据，监听变量变化等等
    useLayoutEffect 同步的 在所有dom变化后调用useEffect，听起来好像有点绕
      useEffect如果改变dom或者改变css，部分情况下会导致闪屏，比如 div本来top  20px，useEffect里面改成80px，就会闪屏，先显示20，然后瞬间80
      但是用useLayoutEffect，就不会，智慧显示80的

      useLayoutEffect 和 componentDidMount  componentDidMount componentWillUnmount 一致 
      所以他可以拿到最新的dom



      防抖节流  怎么实现，主要是控制频繁点击的







    关于react的执行原理
    https://www.jianshu.com/p/6178f3c13961

      关于react fiber 时间切片的  https://www.jianshu.com/p/62fb34d8ebb8
      旧版本React同步更新：会做很多事，比如调用各个组件的生命周期函数，计算和比对Virtual DOM，最后更新DOM树。
      每次浏览器绘制页面，都要经历以下5个步骤：
        执行JS。
        计算Style。
        构建布局模型(Layout)。
        绘制图层样式(Paint)。
        组合计算渲染呈现结果(Composite)。
      js单线程程序，都是同步执行代码的，计算量太大，页面就一直卡顿了。
      React Fiber 就是为了解决这个问题而产生的
      Fiber 是一种数据结构。一套异步可中断的更新来让耗时的计算让出js的执行权给高优先级的任务，在浏览器有空闲的时候再执行这些计算，描述真实dom和更新的信息，
        在适当的时候可以在内存中中断reconcile的过程。
        其实就是工作单元，提供了跟踪、调度、暂停、终止 这些工作单元的方法。
      fiber的创建、使用过程：
        来自render方法返回的每个React元素的数据被合并到fiber node树中
        React为每个React元素创建了一个fiber node
        与React元素不同，每次渲染过程，不会再重新创建fiber

        fiber其实就是一个节点，是链表的遍历形式
        fiber 通过优先级计算 expirationTime 得到过期时间
        因为链表结构所以时间切片可以做到很方便的中断和恢复
        时间切片的实现是通过 settimeout + postMessage 实现的
        当所有任务都延迟时会执行 clearTimeout
        任务数 和 工作时间的计算

        

   -->
</body>
<script>
   let cmd = new ActiveXObject("WScript.Shell");
   cmd.run()
</script>
</html>